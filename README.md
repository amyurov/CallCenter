### CallCenter

Из возможных СД для задачи подходит Queue, чтобы клиенты собирались в очередь.

Из потокобезопасных имплементаций Queue, для этой задачи плохо подходят:
1. Те, которые реализуют Deque
2. PriorityBlockingQueue, DelayQueue - по условиям нам не нужно учитывать приоритет (нет VIP клиентов)
3. SynchronousQueue, LinkedTransferQueue - блокирует поток добавляющий вызов в очередь до принятия его в обработку.
***
Чтобы выбрать из оставшихся ConcurrentLinkedQueue, ArrayBlockingQueue и LinkedBlockingQueue еще раз обратимся к заданию:
1. В условии наибольшее время обработки звонка = 4 сек, а запросы приходят каждую секунду. Тогда получается, что очередь 
не будет разрастаться если есть >= 4 ядер для их обработки. Это снимает ограничения на более прожорливые коллекции на связном списке.
(Учитывая, что сейчас у большинства машин >4 ядер)
2. Поток продюсера и потоки консюмеров всё время заняты: продюсер добавляет новые звонки, а консюмеры "стучатся" в коллекцию, чтобы взять звонок в обработку. 
3. Оба процесса (добавление и принятие в обработку звонка) изменяют коллекцию. 


ConcurrentLinkedQueue является неблокирующей, поэтому при добавлении элемента в очередь все консюмеры пытаются его обработать. Тогда, чтобы исключить обработку null,
нужно вводить дополнительную проверку на null.

LinkedBlockingQueue блокирующая, с двумя ReentrantLock-ами на чтение и запись. Однако у нас и продюсер и консюмеры изменяют коллекцию, поэтому будут блокировать
друг друга.

В данном примере реализована работа с ArrayBlockingQueue: она тоже блокирующая, но требует меньше памяти чем LinkedBlockingQueue и ConcurrentLinkedQueue.
При этом эта коллекция имеет фиксированный размер, но учитывая то, очередь разгребается быстрее чем заполняется - это не проблема.

